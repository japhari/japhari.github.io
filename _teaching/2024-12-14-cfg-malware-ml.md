---
title: "Dynamic Symbolic Execution (DSE) and Malware Analysis in Java Microservices"
excerpt: "Dynamic Symbolic Execution (DSE) is a powerful program analysis technique that combines concrete execution with symbolic analysis to explore program paths comprehensively. This course provides an in-depth understanding of DSE, its integration with Control Flow Graphs (CFGs), and its applications in malware analysis and microservice applications."
collection: teaching
# colab_url: "https://colab.research.google.com/drive/1-T78BMZQg3w9m4iSG2zF154xGAZfcuah"
# github_url: "https://github.com/japhari/natural-language-processing/blob/main/hugging_face_transformer_for_nlp_task.ipynb"
thumbnail: "/images/topics/cfg.png"
type: "Malware - ML"
permalink: /teaching/malware-ai-microservices
venue: "PTIT , Department of Computer Science"
date: 2024-12-14
location: "Hanoi, Vietnam"
categories:
  - teaching
tags:
  - ml
---

# **Comprehensive Course on Dynamic Symbolic Execution (DSE) and Malware Analysis in Java Microservices**

## **Introduction**

Dynamic Symbolic Execution (DSE) is a powerful program analysis technique that combines concrete execution with symbolic analysis to explore program paths comprehensively. This course provides an in-depth understanding of DSE, its integration with Control Flow Graphs (CFGs), and its applications in malware analysis and microservice applications. The course also includes code snippets and real-world examples to solidify the concepts.

---

### **Table of Contents**

1. Introduction to Dynamic Symbolic Execution

   - What is DSE?
   - Applications in Malware Analysis
   - DSE vs. Static Analysis

2. Control Flow Graphs (CFGs) for Program Representation

   - CFG Basics
   - Constructing CFGs
   - Tools for CFG Generation

3. Integration of DSE and CFGs

   - Symbolic Path Exploration
   - Example: Exploring x86 Binaries

4. Tools for Dynamic Symbolic Execution

   - Overview of Tools: Soot, ANGR, and others
   - Setting up ANGR for Binary Analysis

5. Practical Malware Analysis

   - Using DSE for Android APKs
   - Case Study: `towelroot.apk`

6. Advanced Applications

   - Machine Learning and CFGs
   - Vulnerability Detection Using ML and DSE

7. Dynamic Symbolic Execution in Microservices

   - CFGs for Spring Boot Applications
   - Automated Testing of REST APIs
   - Performance Optimization and Dead Code Analysis
   - Service Interaction Analysis

8. Conclusion
   - Challenges and Future Trends

---

## **1. Introduction to Dynamic Symbolic Execution**

### What is DSE?

Dynamic Symbolic Execution is a hybrid program analysis technique where inputs to the program are treated symbolically, and the program is executed to explore all feasible paths. This technique helps identify hidden vulnerabilities and malicious behaviors in binaries.

### Applications in Malware Analysis

- Detection of hidden code paths.
- Analysis of packed or obfuscated binaries.
- Root cause analysis of vulnerabilities.

### DSE vs. Static Analysis

| **Aspect**         | **Dynamic Symbolic Execution**            | **Static Analysis**           |
| ------------------ | ----------------------------------------- | ----------------------------- |
| Input Handling     | Symbolic inputs; explores multiple paths. | Fixed analysis of code paths. |
| Obfuscation Impact | Effective against obfuscation.            | Limited effectiveness.        |
| Runtime Data       | Analyzes real execution data.             | Ignores runtime behavior.     |

---

## **2. Control Flow Graphs (CFGs) for Program Representation**

### CFG Basics

A Control Flow Graph represents the execution paths of a program as nodes (basic blocks) and edges (control flow).

### Constructing CFGs

1. **Static Construction**

   - Extract basic blocks using disassemblers (e.g., IDA Pro).
   - Connect blocks based on branching conditions.

2. **Dynamic Construction**:
   - Use tools like Soot or ANGR to build CFGs during execution.

### Tools for CFG Generation

- **Soot** (for Java programs): Generates CFGs from Java bytecode.
- **ANGR** (for binaries): Handles complex formats like ELF and PE.
- **Ghidra**: Offers CFG visualization for disassembled code.

#### Generating CFG in Java with Soot

```java
import soot.*;
import soot.options.Options;
import soot.toolkits.graph.ExceptionalUnitGraph;
import soot.toolkits.graph.UnitGraph;

public class CFGExample {
    public static void main(String[] args) {
        Options.v().set_prepend_classpath(true);
        Options.v().set_whole_program(true);
        Options.v().set_app(true);
        Options.v().set_soot_classpath("path/to/compiled/classes");

        SootClass c = Scene.v().loadClassAndSupport("YourClassName");
        c.setApplicationClass();

        SootMethod method = c.getMethodByName("main");
        Body body = method.retrieveActiveBody();
        UnitGraph graph = new ExceptionalUnitGraph(body);

        graph.forEach(unit -> {
            System.out.println("Node: " + unit);
            graph.getSuccsOf(unit).forEach(succ -> System.out.println("  -> " + succ));
        });
    }
}
```

---

## **3. Integration of DSE and CFGs**

### Symbolic Path Exploration

Dynamic Symbolic Execution explores paths symbolically to uncover hidden or unreachable paths in binaries.

#### Symbolic Path Exploration for x86 Binaries

1. Extract the CFG.
2. Assign symbolic inputs.
3. Use a path solver to explore feasible paths.

#### ANGR Symbolic Execution

```python
import angr

def analyze_binary(binary_path):
    project = angr.Project(binary_path, auto_load_libs=False)
    cfg = project.analyses.CFGFast()

    # Print nodes and edges
    for node in cfg.graph.nodes:
        print("Node:", node)

    # Symbolic execution
    state = project.factory.entry_state()
    simgr = project.factory.simulation_manager(state)
    simgr.explore(find=lambda s: b"flag" in s.posix.dumps(1))

    if simgr.found:
        print("Flag found:", simgr.found[0].posix.dumps(0))
    else:
        print("Flag not found")

analyze_binary("path/to/binary")
```

---

## **4. Tools for Dynamic Symbolic Execution**

### Overview of Tools

- **Soot**: Java-based CFG and symbolic execution.
- **ANGR**: Python-based framework for binary analysis.
- **Z3 Solver**: SMT solver for symbolic reasoning.

### Setting up ANGR for Binary Analysis

1. Install ANGR:
   ```bash
   pip install angr
   ```
2. Use the above example to explore binaries.

---

## **5. Practical Malware Analysis**

### Using DSE for Android APKs

1. Decompile APKs using tools like JADX.
2. Extract CFGs for native and Java code.
3. Apply DSE to trace paths leading to vulnerabilities.

### Case Study `towelroot.apk`

- Identified mutex vulnerability by tracing CFG paths.
- Explored symbolic execution paths to identify root exploits.

---

## **6. Advanced Applications**

### Machine Learning and CFGs

- **Feature Extraction**: Use node/edge density, clustering coefficients, etc., from CFGs.
- **ML Models**: Train models like Random Forest or SVM for malware classification.

### Vulnerability Detection

- Use DSE to generate symbolic paths.
- Combine with ML for automated detection.

---

## **7. Dynamic Symbolic Execution in Microservices**

### CFGs for Spring Boot Applications

1. Extract CFGs for Spring Boot controllers, services, and repositories.
2. Visualize application flows, including REST API endpoints and service interactions.

#### Code Example: CFG Analysis for a Spring Boot Controller

```java
import soot.*;
import soot.options.Options;
import soot.toolkits.graph.ExceptionalUnitGraph;
import soot.toolkits.graph.UnitGraph;

public class SpringCFG {
    public static void main(String[] args) {
        Options.v().set_prepend_classpath(true);
        Options.v().set_whole_program(true);
        Options.v().set_app(true);
        Options.v().set_soot_classpath("target/classes");

        SootClass controllerClass = Scene.v().loadClassAndSupport("com.example.demo.controller.MyController");
        controllerClass.setApplicationClass();

        SootMethod method = controllerClass.getMethodByName("getData");
        Body body = method.retrieveActiveBody();
        UnitGraph graph = new ExceptionalUnitGraph(body);

        graph.forEach(unit -> {
            System.out.println("Node: " + unit);
            graph.getSuccsOf(unit).forEach(succ -> System.out.println("  -> Successor: " + succ));
        });
    }
}
```

### Automated Testing of REST APIs

- Use symbolic execution to explore all possible input paths for APIs.
- Identify edge cases, including null inputs and boundary conditions.

#### Code Example: ANGR for API Input Validation

```python
import angr

def analyze_service(binary_path):
    project = angr.Project(binary_path, auto_load_libs=False)
    cfg = project.analyses.CFGFast()

    # Identify potential input points (API endpoints)
    for node in cfg.graph.nodes:
        print(f"Analyzing Node: {node}")

    # Perform symbolic execution for inputs
    state = project.factory.entry_state()
    simgr = project.factory.simulation_manager(state)
    simgr.explore(find=lambda s: b"vulnerable" in s.posix.dumps(1))

    if simgr.found:
        print("Vulnerability found:", simgr.found[0].posix.dumps(0))
    else:
        print("No vulnerabilities found")

# Analyze the compiled service binary
analyze_service("path/to/spring-boot-app.jar")
```

### Performance Optimization and Dead Code Analysis

- Use CFG to detect dead code in Spring Boot applications.
- Identify unused controller endpoints or redundant service calls.

### Service Interaction Analysis

#### **Use Case: Mapping Microservice Interactions**

- Generate CFGs for each microservice.
- Identify call chains and dependencies between services.
- Detect bottlenecks or cyclic dependencies in service communication.

#### Code Example: Analyze Microservice Communication

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

@RestController
@RequestMapping("/serviceA")
public class ServiceAController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/process")
    public String process() {
        String response = restTemplate.getForObject("http://serviceB/execute", String.class);
        return "Service A processed: " + response;
    }
}
```

#### Steps:

1. Extract CFGs for `ServiceA` and `ServiceB`.
2. Analyze the call chain from `/serviceA/process` to `/serviceB/execute`.
3. Identify latency or failure points in the communication path.

---

## **8. Conclusion**

Dynamic Symbolic Execution combined with Control Flow Graphs provides a robust framework for analyzing malware, microservices, and detecting vulnerabilities. With advancements in tools and integration with machine learning, DSE is becoming indispensable in cybersecurity and application optimization.

### Key Takeaways

- Learn to construct and analyze CFGs.
- Apply DSE to uncover hidden paths and optimize applications.
- Use tools like Soot and ANGR for real-world analysis.
- Integrate ML for automated vulnerability detection and performance profiling.

---

**Recommended Resources**:

1. [Soot Documentation](https://soot-oss.github.io/soot/)
2. [ANGR Documentation](https://docs.angr.io/)
3. [Z3 Solver](https://github.com/Z3Prover/z3)

**Assignments**:

1. Construct CFGs for a given binary and analyze paths.
2. Use ANGR to symbolically execute a CTF binary and retrieve the flag.
3. Analyze Spring Boot applications to identify dead code and optimize performance.
4. Train a machine learning model using CFG features for vulnerability detection.
5. Map and analyze the interactions between multiple microservices in a distributed system.

Letâ€™s dive deeper into these techniques and push the boundaries of cybersecurity and software engineering research!
